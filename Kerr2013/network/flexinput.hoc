// FLEXINPUT
// This is a collection of scripts for adding flexible input to
// intfcol. The two user-callable functions are "poisforpop", which
// adds Poisson noise to a list of cell populations, and "poisforcell",
// which adds it to a list of cell IDs.
//
// Version: 2012jun24 by Cliff Kerr (cliffk@neurosim.downstate.edu)


// Annoying house keeping -- initialize random number generators
objref randcond
randcond = new Random(0) // Set the seed to something arbitrary
randcond.uniform(0,1) // Create a random variable on the range [0,1] -- used in flexinput.hoc for repicking


// POISFORPOP
// This function adds an arbitrary Poisson input to a particular
// population or populations of cells. It calls basestim followed
// by stimadd.
// Usage:
//   poisforpop(tsignal,psignal,maxrate,cellpop,cellprct,cellwt,whichsy)
// where
//   tsignal describes the points in time that probability (psignal) is defined at
//   psignal describes the probability of a spike at a given time (e.g. a 10K-element sine wave)
//   maxrate is the number of spikes (in ms^-1 I think) (note: signal.size() must be greater than (timef-timei)*freq!)
//   cellpop is a vector of cell populations (e.g. [E2,E4,E5])
//   cellprct is the percentage of cells within a population being stimulated
//   cellwt is the weight given to each spike  (e.g. 1e9)
//   whichsy is the synapse used (e.g. AM2)
//
// Version: 2012may08
proc poisforpop () { local maxrate,cellpop,cellprct,cellwt,whichsy,npops,cellstart,cellfinish,pickthiscell localobj tsignal,psignal,spkoutput
  tsignal=$o1 // Signal to base the Poisson spike train on
  psignal=$o2 // Signal to base the Poisson spike train on
  maxrate=$3 // Frequency/rate of the signal
  cellpop=$4 // Cell population to add signal to
  cellprct=$5 // Percent of cells to stimulate in each population
  cellwt=$6 // Weight of each synapse
  whichsy=$7 // Type of each synapse
  for h=0,numcols-1 { // Loop over columns
   	cellstart=col[h].ix[cellpop] // Starting cell index
  	cellfinish=col[h].ixe[cellpop] // Finishing cell index
  	for cellid=cellstart,cellfinish { // Loop over each cell in the population
  		pickthiscell=100*randcond.repick() // Whether or not to pick this cell
  		if(cellprct>pickthiscell) { // Pick out cellprct percent of cells
  			spkoutput=basestim(tsignal,psignal,maxrate) // Calculate Poisson train
  			stimadd(spkoutput,cellid,cellwt,whichsy) // Add the spikes to this cell
  		}
  	}
  }
}




// POISFORCELL
// This function adds an arbitrary Poisson input to a precise
// selection of cells. Otherwise it resembles poisforpop. It calls 
// basestim followed by stimadd.
// Usage:
//   poisforcell(tsignal,psignal,maxrate,cellids,cellwt,whichsy)
// where
//   tsignal describes the points in time that probability (psignal) is defined at
//   psignal describes the probability of a spike at a given time (e.g. a 10K-element sine wave)
//   maxrate is the number of spikes (in Hz, e.g. 10) (note: signal.size() must be greater than (timef-timei)*freq!)
//   cellids is a vector of cell IDs (e.g. [418,419,420...])
//   cellwt is the weight given to each spike  (e.g. 1e9)
//   whichsy is the synapse used (e.g. AM2)
//
// Version: 2011oct18
proc poisforcell () { local maxrate,cellwt,whichsy,cellid localobj tsignal,psignal,cellids,spkoutput
  tsignal=$o1 // Time signal to base the Poisson spike train on
  psignal=$o2 // Probability signal to base the Poisson spike train on
  maxrate=$3 // Frequency/rate of the signal
  cellids=$o4 // Cell populations to add signal to
  cellwt=$5 // Weight of each synapse
  whichsy=$6 // Type of each synapse
  
  for vtr(&cellid,cellids) { // Loop over each cell in the population using Bill's vector iterator
	spkoutput=basestim(tsignal,psignal,maxrate) // Calculate Poisson train
	stimadd(spkoutput,cellid,cellwt,whichsy)
  }
}





// BASESTIM -- arbitrary Poisson generator
// Usage:
// 	spktimevec = basestim(tsignal,psignal,maxrate)
//
// where:
// 	tsignal is the time points of the signal -- e.g. LFP times (in s, not ms!!)
// 	psignal is the probability at each time point -- e.g. LFP voltage
// 	maxrate gives the maximum rate of the stimulus
//
// Example: 
// 	objref tsignal, psignal, output
// 	tsignal=new Vector()
//	tsignal.append(0, 0.5, 0.7, 1.0, 1.5, 2.0)
// 	psignal=new Vector()
//	psignal.append(0, 0.5,   0, 0.2,   0,   0)
// 	maxrate=50
// 	output=basestim(tsignal,psignal,maxrate)
//
// Version: 2012oct04
obfunc basestim () { local i,nspks,maxrate localobj spktimevec,tmpvec,tsignal,psignal
  tsignal=$o1 psignal=$o2 maxrate=$3 // Handle input arguments
  spktimevec = new Vector()
  tmpvec = new Vector(10000)
  
  for i=0,tsignal.size-2 { // Loop over each entry in the signal vector; -2 because looking at time intervals
  	
  	nspks = maxrate*(tsignal.x[i+1]-tsignal.x[i])*psignal.x[i] // The number of spikes to place in this time interval
  	nspks = round(nspks*2*randcond.repick()) // Introduce some randomness
  	if (nspks>0) { // Don't continue if no spikes
  		tmpvec.resize(nspks) // Initialize spike vector
	  	tmpvec.setrand(randcond) // Populate with random numbers -- used to use setrnd() but that seemed to be messing things up...
	  	tmpvec.sort // Sort into increasing times
	  	tmpvec.mul(tsignal.x[i+1]-tsignal.x[i]) // Scale to be the right time interval
	  	tmpvec.add(tsignal.x[i]) // Add the starting time back
	  	spktimevec.append(tmpvec) // Save the spikes for this interval
	  	}
  	}
  return spktimevec
}



// STIMADD -- add stimulus to the input list for a single cell
// This function, based on sgrcells, adds an arbitrary
// stimulus to the rest of the input NQS table vq.
// Usage:
//	 stimadd(times,cellid,cellwt,whichsy)
// where
//	 times is a length-N vector of spike times (e.g. 0, 1.34, 2.53, 7.34, 7.45)
//	 cellid is the cell ID (e.g. 142)
//   cellwt is the synaptic weight (e.g. 1e9)
//   whichsy is the synapse type (e.g. AMPA)
// Version: 2011may20
proc stimadd () { local cellid,cellwt,whichsy,npts,ii,foo localobj times,vqtmp
   if (vq==nil) vq=new NQS("ind","time","cellwt","whichsy") // Initialize NQS to store spikes
   vqtmp=new NQS("ind","time","cellwt","whichsy")
   times=$o1 // Incoming spike times (e.g. 0, 1.34, 2.53, 7.34, 7.45)
   cellid=$2 // Cell ID (e.g. 142)
   cellwt=$3 // Synaptic weights (e.g. 1e9)
   whichsy=$4 // Synapse type (e.g. AMPA)
   npts=times.size() // Find the number of points
   for ii=0,3 vqtmp.v[ii]=new Vector(npts) // Initialize vectors
   vqtmp.v[0].fill(cellid) // Assign the cell ID
   vqtmp.v[1]=times // Assign the times to the second column
   vqtmp.v[2].fill(cellwt) // Assign weights
   vqtmp.v[3].fill(whichsy) // Assign synapse type
   vqtmp.pad() // Shouldn't be necessary, but it is -- make sure all columns are the same size
   vq.append(vqtmp) // Append to original array -- won't take effect until pushspks() call, however
   nqsdel(vqtmp) // Garbage collection
 }
